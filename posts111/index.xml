<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts111s on 老陳网志</title>
    <link>/posts111/</link>
    <description>Recent content in Posts111s on 老陳网志</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <copyright>&amp;copy; 2021 &lt;a href=&#34;https://www.chenplus.com/&#34;&gt; ChenPlus.com &lt;/a&gt; &lt;a href=&#34;&#34;&gt; 渝ICP备18007511号 &lt;/a&gt;
</copyright>
    <lastBuildDate>Sat, 23 Jan 2021 09:57:16 +0800</lastBuildDate><atom:link href="/posts111/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>一文完全掌握 Go math/rand</title>
      <link>/posts111/2021-01-23-rand/</link>
      <pubDate>Sat, 23 Jan 2021 09:57:16 +0800</pubDate>
      
      <guid>/posts111/2021-01-23-rand/</guid>
      <description>Go 获取随机数是开发中经常会用到的功能, 不过这个里面还是有一些坑存在的, 本文将完全剖析 Go math/rand, 让你轻松使用 Go Rand. 开篇一问: 你觉得 rand 会 panic 吗 ? 源码剖析 math/rand 源码其实很简单, 就两个比较重要的函数 func (rng *rngSource) Seed(seed int64) { rng.tap = 0 rng.feed = rngLen - rngTap //... x := int32(seed) for i := -20; i &amp;lt; rngLen; i++ { x = seedrand(x) if i &amp;gt;= 0 { var u int64 u = int64(x) &amp;lt;&amp;lt; 40 x = seedrand(x) u ^= int64(x) &amp;lt;&amp;lt; 20 x = seedrand(x) u ^= int64(x) u ^= rngCooked[i] rng.vec[i] = u } } } 这个函数就是在设置 seed, 其实就是对 rng.vec 各个位置设</description>
    </item>
    
    <item>
      <title>当 Go struct 遇上 sync</title>
      <link>/posts111/2020-12-22-struct-sync/</link>
      <pubDate>Tue, 22 Dec 2020 00:21:52 +0800</pubDate>
      
      <guid>/posts111/2020-12-22-struct-sync/</guid>
      <description>struct 是我们写 Go 必然会用到的关键字, 不过当 struct 遇上一些比较特殊类型的时候, 你注意过你的程序是否正常吗 ? 一段代码 type URL struct { Ip string Port string mux sync.RWMutex params url.Values } func (c *URL) Clone() URL { newUrl := URL{} newUrl.Ip = c.Ip newUrl.params = url.Values{} return newUrl } 这段代码你能看出来问题所在吗 ? A: 程序正常 B: 编译失败 C: panic D: 有可能发生 data race E: 有可能发生死锁 如果你看出来问题在哪里的话, 那我再悄悄告诉你, 这段代码是 github 某 3k star Go 框架的底层核心代码, 那你是不是就</description>
    </item>
    
    <item>
      <title>疑惑: Go const 会导致程序结果错乱 ?</title>
      <link>/posts111/2020-12-17-const-int/</link>
      <pubDate>Thu, 17 Dec 2020 23:32:12 +0800</pubDate>
      
      <guid>/posts111/2020-12-17-const-int/</guid>
      <description>const 是 Go 里面我们经常使用的关键字, 基本上很难玩出花来. 不过某些特殊情况下 const 会出现你意想不到的结果 场景模拟 某公司某次营销活动中, 会根据用户 VIP 级别送用户一些优惠券, 最大面值520. 某用户发现自己购买的 500 元钱的商品, 使用 520 的优惠券来支付, 理论上能 0 元购买的商品, 最后却需要支付一个天文数字. 这个场景是我自己随便想的, 如果过于夸张, 请原谅我. ^^ 下面我们用代码大</description>
    </item>
    
    <item>
      <title>你真的懂 golang reslice 吗</title>
      <link>/posts111/2020-10-20-golang-slice/</link>
      <pubDate>Tue, 20 Oct 2020 10:17:05 +0800</pubDate>
      
      <guid>/posts111/2020-10-20-golang-slice/</guid>
      <description>package main func a() []int { a1 := []int{3} a2 := a1[1:] return a2 } func main() { a() } 看到这个题, 你的第一反应是啥? (A) 编译失败 (B) panic: runtime error: index out of range [1] with length 1 (C) [] (D) 其他 第一感觉: 肯定能编译过, 但是运行时一定会panic的. 但事与愿违竟然能够正常运行, 结果是:[] 疑问 a1 := []int{3} a2 := a1[1:] fmt.Println(&amp;quot;a[1:]&amp;quot;, a2) a1 和 a2 共享同样的底层数组, len(a1) = 1, a1[1]绝对会panic, 但是a[1:]却能正常输出, 这是为何? 从表面入手 整体上看下整体</description>
    </item>
    
    <item>
      <title>限流器系列(3)--自适应限流</title>
      <link>/posts111/2020-07-05-bbr/</link>
      <pubDate>Sun, 23 Aug 2020 11:59:45 +0800</pubDate>
      
      <guid>/posts111/2020-07-05-bbr/</guid>
      <description>漏斗桶/令牌桶确实能够保护系统不被拖垮, 但不管漏斗桶还是令牌桶, 其防护思路都是设定一个指标, 当超过该指标后就阻止或减少流量的继续进入，当系统负载降低到某一水平后则恢复流量的进入。但其通常都是被动的，其实际效果取决于限流阈值设置是否合理，但往往设置合理不是一件容易的事情. 项目日常维护中, 经常能够看到某某同学在群里说:xx系统429了, 然后经过一番查找</description>
    </item>
    
    <item>
      <title>限流器系列(2) -- Token Bucket 令牌桶</title>
      <link>/posts111/2020-06-30-token-bucket/</link>
      <pubDate>Tue, 30 Jun 2020 18:38:23 +0800</pubDate>
      
      <guid>/posts111/2020-06-30-token-bucket/</guid>
      <description>上一篇说到 Leaky Bucket 能限制客户端的访问速率, 但是无法应对突发流量, 本质原因就是漏斗桶只是为了保证固定时间内通过的流量是一样的. 面对这种情况, 本篇文章继续介绍另外一种限流器: Token Bucket &amp;ndash; 令牌桶 什么是 Token Bucket 漏斗桶的桶空间就那么大, 其只能保证桶里的请求是匀速流出, 并不关心流入的速度, 只要桶溢出了就服务拒绝, 这可能并不符合互联网行业的使用场景. 试想这样的场景, 尽管服务器</description>
    </item>
    
    <item>
      <title>限流器系列(1) -- Leaky Bucket 漏斗桶</title>
      <link>/posts111/2020-06-27-leaky-bucket/</link>
      <pubDate>Sat, 27 Jun 2020 10:14:07 +0800</pubDate>
      
      <guid>/posts111/2020-06-27-leaky-bucket/</guid>
      <description>限流器(Rate Limiter)在微服务中的重要性不言而喻了. 下游服务的稳定性, 防止过载, 全靠这个组件来保证. 限流器的实现方式, 基本有下面几种方式 计数器 漏斗通 (Leaky Bucket) 令牌桶 (Token Bucket) 基于 BBR 算法的自适应限流 基于 Nginx 的限流 分布式限流 这个系列的文章会逐一介绍各种限流器. 本篇文章会结合比较成熟组件介绍: 漏斗桶 什么是限流器 Web servers typically use a central in-memory key-value database, like Redis or Aerospike, for session management. A rate limiting algorithm is used to check</description>
    </item>
    
    <item>
      <title>Bilibili Kratos 框架源码分析(4) -- Kratos Log</title>
      <link>/posts111/2020-06-09-kratos-log/</link>
      <pubDate>Tue, 09 Jun 2020 10:14:07 +0800</pubDate>
      
      <guid>/posts111/2020-06-09-kratos-log/</guid>
      <description>用法 flag env type remark log.v LOG_V int 日志级别：DEBUG:0 INFO:1 WARN:2 ERROR:3 FATAL:4 log.stdout LOG_STDOUT bool 是否标准输出：true、false log.dir LOG_DIR string 日志文件目录，如果配置会输出日志到文件，否则不输出日志文件 log.module LOG_MODULE string 可单独配置每个文件的verbose级别：file=1,file2=2 log.filter LOG_FILTER string 过虑敏感信息 format: field1,field2. 被阉割的功能: log.agent 配置文件 [log] family = &amp;quot;xxx-service&amp;quot; dir = &amp;quot;/data/log/xxx-service/&amp;quot; stdout = true v = 3 filter = [&amp;quot;fileld1&amp;quot;, &amp;quot;field2&amp;quot;] [log.module] &amp;quot;dao_user&amp;quot; = 2 &amp;quot;servic*&amp;quot; = 1 对应的加载方法 // cmd/main.go func main() { paladin.Init() var</description>
    </item>
    
    <item>
      <title>Bilibili Kratos 框架源码分析(3) -- fanout异步</title>
      <link>/posts111/2020-05-22-kratos-fanout/</link>
      <pubDate>Fri, 22 May 2020 10:14:07 +0800</pubDate>
      
      <guid>/posts111/2020-05-22-kratos-fanout/</guid>
      <description>在写项目代码时如果遇到需要异步处理时, 如异步更新 redis, 异步比对数据等等, 我们的常规处理一般是 MQ. 但有的时候我们的操作其实很简单, 写 MQ 显得又太重了, 那么该如何在程序里实现一个异步功能? 本篇文章就介绍下 Kratos 官方 wiki 没有提到的功能 Fanout. 其实Fanout 在 生成的 kratos-demo 里面是有体现的, 只是没有使用 demo 而已 type dao struct { ... cache *fanout.Fanout ... } func newDao(r *redis.Redis, mc *memcache.Memcache, db *sql.DB) (d *dao, cf func(), err error) { ... d = &amp;amp;dao{ ... cache: fanout.New(&amp;quot;cache&amp;quot;), ... } cf = d.Close return }</description>
    </item>
    
    <item>
      <title>Bilibili Kratos 框架源码分析(2) -- Kratos 一些简单例子</title>
      <link>/posts111/2020-05-16-kratos-demo/</link>
      <pubDate>Sat, 16 May 2020 10:14:07 +0800</pubDate>
      
      <guid>/posts111/2020-05-16-kratos-demo/</guid>
      <description>本篇主要介绍四种使用 kratos 的例子. 前情透漏, 这一篇的篇幅比较长, 如果已经会用 Kratos 的可以跳过这一节 http 服务 http 服务其实就比较简单, 开篇的Golang 大法好 ！！直接就能对外提供 http 服务. http server默认有两个函数howToStart, ping. 关于ping 函数后面再具体看其作用 如何添加一个新的 api 接口? // internal/server/http/server.go func initRouter(e *bm.Engine) { e.Ping(ping) g := e.Group(&amp;quot;/kratos-demo&amp;quot;) { g.GET(&amp;quot;/start&amp;quot;, howToStart) g.GET(&amp;quot;/sayHi&amp;quot;, sayHi) g.GET(&amp;quot;/sayHello&amp;quot;, func(context *bm.Context) { svc.SayHello(context, &amp;amp;pb.HelloReq{ Name: &amp;quot;test&amp;quot;, }) context.JSON(&amp;quot;success&amp;quot;, nil) }) } v2Group := e.Group(&amp;quot;/kratos-demo/v2&amp;quot;) { v2Group.GET(&amp;quot;/sayHi&amp;quot;, sayHi) }</description>
    </item>
    
    <item>
      <title>Bilibili Kratos 框架源码分析(1) -- 启动流程</title>
      <link>/posts111/2020-05-08-kratos-flow/</link>
      <pubDate>Fri, 08 May 2020 14:42:38 +0800</pubDate>
      
      <guid>/posts111/2020-05-08-kratos-flow/</guid>
      <description>这里先吐槽一下 kratos 官方 wiki 写的实在不咋地, 一些很基本的使用方法, 一些很好的功能都没有体现出现, 同时也建议多去 github issue 里去找找答案, 那里面比 wiki 详细很多. 这个系列的文章我会基于 v0.4.2 这个版本的源码进行. 现在正式进入这个系列源码的第一篇: Kratos 启动流程 安装 kratos 至于如何安装 kratos, 请参考 官方wiki, Kratos 官方推荐方式: GO111MODULE=on &amp;amp;&amp;amp; go get -u github.com/go-kratos/kratos/tool/kratos, 不过有可能你依然无法安装成功. 特别是 bilibili/kratos 迁移到 go-kratos/kratos 之后,</description>
    </item>
    
    <item>
      <title>一次错误使用 go-cache 导致出现的线上问题</title>
      <link>/posts111/2020-03-11-go-cache/</link>
      <pubDate>Wed, 11 Mar 2020 16:30:35 +0800</pubDate>
      
      <guid>/posts111/2020-03-11-go-cache/</guid>
      <description>话说一个美滋滋的上午, 突然就出现大量报警, 接口大量请求都响应超时了. 排查过程 查看服务器的监控系统, CPU, 内存, 负载等指标正常 排查日志, 日志能够响应的结果也正常. request.log 中响应时长高达数秒 查看数据库, codis 监控, 各项指标正常 不得已, 只能打开线上 pprof 查看 Go 相关参数是否正常. 果真一下子就找到问题发生的原因 这是当时线上 pprof 的截图, 发现 40 多万 goroutine 都阻塞在 go-cache 的 Set 函数上. 更准确的说</description>
    </item>
    
    <item>
      <title>如何用 Redigo 访问 Codis</title>
      <link>/posts111/2020-01-06-redigo-codis/</link>
      <pubDate>Mon, 06 Jan 2020 13:58:36 +0800</pubDate>
      
      <guid>/posts111/2020-01-06-redigo-codis/</guid>
      <description>开篇依然是那三个问题: redigo 是否能够用于 codis ? 如果不经过任何加工, 直接用 redigo 去访问 codis, 会出现什么样的问题 ? codis 的 golang 客户端如何实现 ? 先贴出来, 我之前直接用 Redigo 接入 codis 的代码 // Redis global redis connection pool var Redis *redis.Pool var RedisInitErr = errors.New(&amp;quot;init redis error&amp;quot;) Redis = &amp;amp;redis.Pool{ MaxIdle: 10, Dial: func() (conn redis.Conn, e error) { addrs, err := getHosts() if err != nil { panic(&amp;quot;init redis panic&amp;quot;) } rand.Seed(time.Now().UnixNano()) rand.Shuffle(len(addrs), func(i, j int) { addrs[i], addrs[j] = addrs[j], addrs[i] }) var handler redis.Conn for _, v := range addrs { var err error handler, err = redis.Dial(&amp;quot;tcp&amp;quot;, v) if err != nil || handler == nil { continue } res, err := handler.Do(&amp;quot;PING&amp;quot;) if pong, err := redis.String(res, err); err != nil &amp;amp;&amp;amp; pong != &amp;quot;PONG&amp;quot;</description>
    </item>
    
    <item>
      <title>Redigo Pool 源码解析</title>
      <link>/posts111/2019-12-31-redigo-pool/</link>
      <pubDate>Tue, 31 Dec 2019 16:57:33 +0800</pubDate>
      
      <guid>/posts111/2019-12-31-redigo-pool/</guid>
      <description>Redigo Pool 最重要的结构 type Pool struct { // 真正获取跟redis-server连接的函数, 必填参数 Dial func() (Conn, error) // 这是个可选参数, 用于在从 pool 获取连接时, 检查这个连接是否正常使用. 所以这个参数一般是必填的 TestOnBorrow func(c Conn, t time.Time) error // 最多有多少个空闲连接保留, 一般必填 MaxIdle int // 最多有多少活跃的连接数, 一般必填 MaxActive int // 空闲连接最长空闲时间, 一般必填 IdleTimeout time.Duration // Pool 的活跃的连接数达到 MaxActive, 如果 Wait 为 true, // 那么 Get() 将要</description>
    </item>
    
    <item>
      <title>打造 Zap 开箱即用日志组件</title>
      <link>/posts111/2019-12-15-zap-common-logger/</link>
      <pubDate>Sun, 15 Dec 2019 22:49:01 +0800</pubDate>
      
      <guid>/posts111/2019-12-15-zap-common-logger/</guid>
      <description>logrus 是 golang 一款非常优秀的日志框架, 其优点非常明显: 优雅的代码框架设计, 可以作为我们设计组件的参考. 具体请参见我前面文章(链接文末给出) 使用简单 组件化的开发思路 灵活的输出方式 但是, 性能终究是忍痛舍弃 logrus 的“阿喀琉斯之踵”, 前面的文章深入研究了 logrus 性能低的原因 目前 golang 日志库的大众选择主要集中在: logrus, zap, zerolog. zap 和 zerolog 的性能都是优秀的, 但是从用法习惯上我更倾向于 zap. 简单介绍 Zap</description>
    </item>
    
    <item>
      <title>Logrus源码阅读(2)--logrus生命周期</title>
      <link>/posts111/2019-10-05-logrus-life-cycle/</link>
      <pubDate>Sat, 05 Oct 2019 11:21:24 +0800</pubDate>
      
      <guid>/posts111/2019-10-05-logrus-life-cycle/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Golang是否真的没有指针运算?</title>
      <link>/posts111/2019-07-22-golang-pointer/</link>
      <pubDate>Mon, 22 Jul 2019 11:48:24 +0800</pubDate>
      
      <guid>/posts111/2019-07-22-golang-pointer/</guid>
      <description>答案是肯定的: 没有指针运算(哈哈, 别着急慢慢往后面看) func main() { a1 := []int{1, 2, 3} p1 := &amp;amp;a1[0] fmt.Println(reflect.TypeOf(p1)) // *int fmt.Println(&amp;quot;p1: &amp;quot;, *p1) // 1 fmt.Printf(&amp;quot;p1 address:%p\n&amp;quot;, p1) // 0xc00009a000 p1 = p1 + 1 } invalid operation: p1 + 1 (mismatched types *int and int) C或者C++转golang同学就高兴了, 再也不用面试的时候去面对下面这道题了(面试C++的时候, 基本每家公司的笔试题上都会有这道题) #include&amp;lt;stdio.h&amp;gt; void main() { int a[5]={1,2,3,4,5}; int *ptr=(int *)(&amp;amp;a+1); printf(&amp;quot;%d,%d&amp;quot;,*(a+1),*(ptr-1)); } 这题的结果是: 2和5 可惜高兴的太早了. golang虽说指针变量</description>
    </item>
    
    <item>
      <title>Logrus源码阅读(1)--基本用法</title>
      <link>/posts111/2019-06-11-logurs-1/</link>
      <pubDate>Tue, 16 Jul 2019 20:06:27 +0800</pubDate>
      
      <guid>/posts111/2019-06-11-logurs-1/</guid>
      <description>选择golang日志库时, 使用logrus的主要原因就是因为star比较多, 而且社区活跃度非常高. 在项目使用过程中, 发现logrus的调用入口, 性能, 插件, 自定义插件, 输出格式等都非常优秀, 值得学习一下 整体结构图 整体来看总共提供两种方式调用: logrus.Info(&amp;ldquo;hello logrus&amp;rdquo;) logrus.WithField(logruns.Fields{&amp;ldquo;key1&amp;rdquo;:&amp;ldquo;v1&amp;rdquo;}).Info(&amp;ldquo;hello logrus&amp;rdquo;) 这些函数都在exported.go文件中. 当然为了提供不同级别输出日志的功能, 里面实现了各种各样的p</description>
    </item>
    
    <item>
      <title>一次golang deadlock的讨论</title>
      <link>/posts111/2019-07-11-deadlock-detector/</link>
      <pubDate>Thu, 11 Jul 2019 10:44:07 +0800</pubDate>
      
      <guid>/posts111/2019-07-11-deadlock-detector/</guid>
      <description>背景 在微信群一位同学抛出的一段代码, 各位看官猜想一下程序的执行结果 // 程序1 func main() { fmt.Println(&amp;quot;running, not deadlock&amp;quot;) server, err := net.Listen(&amp;quot;tcp&amp;quot;, &amp;quot;127.0.0.1:9001&amp;quot;) if err != nil { fmt.Println(err) } waitQueue := make(chan int) for { connection, err := server.Accept() if err != nil { panic(&amp;quot;server&amp;quot;) } fmt.Printf(&amp;quot;Received connection from %s.\n&amp;quot;, connection.RemoteAddr()) waitQueue &amp;lt;- 1 } } 我猜想大部分同学都会说是: fatal error: all goroutines are asleep - deadlock!. 因为waitQueue是个没有缓冲的channel, waitQueue &amp;lt;- 1向里面send一个值, 理论上程序一运行就会报deadlock的错误 如下面这个例子 // 程序</description>
    </item>
    
    <item>
      <title>我所理解的Sync Pool</title>
      <link>/posts111/2019-05-26-sync-pool/</link>
      <pubDate>Sat, 08 Jun 2019 22:22:15 +0800</pubDate>
      
      <guid>/posts111/2019-05-26-sync-pool/</guid>
      <description>看gin源码时发现了sync.Pool的使用 // gin.go:L144 func New() *Engine { ... engine.pool.New = func() interface{} { return engine.allocateContext() } return engine } // gin.go: L346 func (engine *Engine) ServeHTTP(w http.ResponseWriter, req *http.Request) { c := engine.pool.Get().(*Context) c.writermem.reset(w) c.Request = req c.reset() engine.handleHTTPRequest(c) engine.pool.Put(c) } 那个时候其实不太明白这个Pool是在干啥用, 大致觉得应该是内存池之类的. 后面想仔细看下sync.Pool具体怎么用, 我就去直接看了下Pool的源码, 然后直接懵逼了 因为基本看不懂其逻辑, 因为Pool的源码涉及到Golang的调度</description>
    </item>
    
    <item>
      <title>[每日一译]golang range与iteration之间的关系</title>
      <link>/posts111/2019-06-04-golang-range-address-of-iterator/</link>
      <pubDate>Tue, 04 Jun 2019 11:11:54 +0800</pubDate>
      
      <guid>/posts111/2019-06-04-golang-range-address-of-iterator/</guid>
      <description>原文地址 package main import ( &amp;quot;fmt&amp;quot; ) type T struct { id int } func main() { t1 := T{id: 1} t2 := T{id: 2} ts1 := []T{t1, t2} ts2 := []*T{} for _, t := range ts1 { ts2 = append(ts2, &amp;amp;t) } for _, t := range ts2 { fmt.Println((*t).id) } } 先不要看结果, 自己想想输出是什么? 对于很多人(包括我自己), 结果可能会让人感到惊讶 2 2 我个人期待的结果, 但是这是一个错误结果 1 2 迭代变量t使用短变量声明的方式声明, 它的声明周期就是for代码块. 这个变量在第一次循环时是第一个元素的值, 在</description>
    </item>
    
    <item>
      <title>[每日一译] Tags in Golang</title>
      <link>/posts111/2019-06-03-tags-of-golang/</link>
      <pubDate>Mon, 03 Jun 2019 22:22:15 +0800</pubDate>
      
      <guid>/posts111/2019-06-03-tags-of-golang/</guid>
      <description>原文地址: Tags in Golang 我们声明golang struct时可以在struct字段后面添加一些字符串来丰富这个字段, 这些字符串称为tag. Tags可以被当前package或者包外使用. 让我们首先看看struct是如何声明的, 然后深入研究下tag本身, 最后用几个例子结束 Struct type struct是一系列的字段的组合. 每一个字段都由一个optional名字和require</description>
    </item>
    
    <item>
      <title>gin源码阅读之四 -- gin的路由算法</title>
      <link>/posts111/2019-03-04-gin-04/</link>
      <pubDate>Mon, 04 Mar 2019 19:53:52 +0800</pubDate>
      
      <guid>/posts111/2019-03-04-gin-04/</guid>
      <description>gin的是路由算法其实就是一个Radix Tree. 有关数据结构的可以自己去网上找相关资料查看. 注册路由预处理 我们在使用gin时通过下面的代码注册路由 普通注册 router.POST(&amp;quot;/somePost&amp;quot;, func(context *gin.Context) { context.String(http.StatusOK, &amp;quot;some post&amp;quot;) }) 使用中间件 router.Use(Logger()) 使用Group v1 := router.Group(&amp;quot;v1&amp;quot;) { v1.POST(&amp;quot;login&amp;quot;, func(context *gin.Context) { context.String(http.StatusOK, &amp;quot;v1 login&amp;quot;) }) } 这些操作, 最终都会在反应到gin的路由树上 具体实现 // routergroup.go:L72-77 func (group *RouterGroup) handle(httpMethod, relativePath string, handlers HandlersChain) IRoutes { absolutePath := group.calculateAbsolutePath(relativePath) // &amp;lt;--- handlers = group.combineHandlers(handlers) // &amp;lt;--- group.engine.addRoute(httpMethod, absolutePath, handlers) return group.returnObj() } 在调用POST, GET, HEAD等</description>
    </item>
    
    <item>
      <title>gin源码阅读之三 -- gin牛逼的context</title>
      <link>/posts111/2019-01-21-gin-03/</link>
      <pubDate>Thu, 21 Feb 2019 21:15:29 +0800</pubDate>
      
      <guid>/posts111/2019-01-21-gin-03/</guid>
      <description>Gin封装的最好的地方就是context和对response的处理. github的README的介绍, 基本就是对这两个东西的解释. 本篇文章主要解释context的使用方法, 以及其设计原理 为什么要将Request的处理封装到Context中 在阅读gin的源码时, 请求的处理是使用type HandlerFunc func(*Context)来处理的. 也就是 func(context *gin.Context) { context.String(http.StatusOK, &amp;quot;some post&amp;quot;) } 参数是</description>
    </item>
    
    <item>
      <title>gin源码阅读之二 -- 揭开gin的神秘面纱</title>
      <link>/posts111/2019-02-18-gin-02/</link>
      <pubDate>Mon, 18 Feb 2019 21:01:01 +0800</pubDate>
      
      <guid>/posts111/2019-02-18-gin-02/</guid>
      <description>上一篇简单介绍了gin, 以及net/http是如何数据流转的, 本篇将详细介绍gin 数据如何在gin中流转 package main import &amp;quot;github.com/gin-gonic/gin&amp;quot; func main() { r := gin.Default() r.GET(&amp;quot;/ping&amp;quot;, func(c *gin.Context) { c.JSON(200, gin.H{ &amp;quot;message&amp;quot;: &amp;quot;pong&amp;quot;, }) }) r.Run() // listen and serve on 0.0.0.0:8080 } 这段代码的大概流程: r := gin.Default()初始化了相关的参数 /ping将路由及处理handler注册到路由树中 启动服务 r.Run()其实调用的是err = http.ListenAndServe(address, engine), 结合上一篇文章可以看出来,</description>
    </item>
    
    <item>
      <title>gin源码阅读之一 -- net/http的大概流程</title>
      <link>/posts111/2019-02-17-gin-01/</link>
      <pubDate>Sun, 17 Feb 2019 14:59:42 +0800</pubDate>
      
      <guid>/posts111/2019-02-17-gin-01/</guid>
      <description>最近公司大部分项目开始往golang换, api的框架选定使用gin, 于是将gin的源码看了一遍, 会用几篇文章将gin的流程及流程做一个梳理, 下面进入正题. gin框架预览 上图大概是gin里面比较重要的模块. 从gin的官方第一个demo入手. package main import &amp;quot;github.com/gin-gonic/gin&amp;quot; func main() { r := gin.Default() r.GET(&amp;quot;/ping&amp;quot;, func(c *gin.Context) { c.JSON(200, gin.H{ &amp;quot;message&amp;quot;: &amp;quot;pong&amp;quot;, }) }) r.Run() // listen and serve on 0.0.0.0:8080 } r.Run()的源码: func (engine *Engine) Run(addr ...string) (err error) { defer func() { debugPrintError(err) }() address := resolveAddress(addr) debugPrint(&amp;quot;Listening</description>
    </item>
    
    <item>
      <title>GraphQL N&#43;1 问题解决方案</title>
      <link>/posts111/hugo-integrated-gitment-plugin/</link>
      <pubDate>Mon, 12 Nov 2018 18:43:15 +0800</pubDate>
      
      <guid>/posts111/hugo-integrated-gitment-plugin/</guid>
      <description>什么是N+1问题 { topStories(limit: 10) { title author { name email } } } 这个简单的查询, 在Queryresolve里面会查询到top10 story, 但是StoryType却会调用10次author查询. 大概的SQL查询: select * from stories limit 10 select * from author where stories.author_id = x select * from author where stories.author_id = x select * from author where stories.author_id = x ... select * from author where stories.author_id = x 这个简单的Query就会查询11次数据库. 我们要知道Graphql的图形结构可能是个闭环结构,</description>
    </item>
    
    <item>
      <title>MongoDB 数据重复的处理方法</title>
      <link>/posts111/2018-09-30-mongo-duplicate/</link>
      <pubDate>Sun, 30 Sep 2018 20:47:53 +0800</pubDate>
      
      <guid>/posts111/2018-09-30-mongo-duplicate/</guid>
      <description>背景 在使用mongodb的过程中, 发现某张表因为一个bug引入了重复数据. 这个表的数据高达210多万条, 使用程序遍历查找重复数据, 并删除这些重复数据, 会显得不太合理. 下面是我解决这个问题的方法. 引起问题的原因 确实有程序bug的影响 表相关字段没有使用unique索引 解决方式 一. 错误的解决方式 相当多的文章是用下面的解决方式: db.test.ensureIndex({id: 1,name: 1}, {unique: true, dropDups: true}) 这种方式由于B</description>
    </item>
    
    <item>
      <title>ES简单使用</title>
      <link>/posts111/2018-09-28-es-simple/</link>
      <pubDate>Thu, 27 Sep 2018 11:44:44 +0800</pubDate>
      
      <guid>/posts111/2018-09-28-es-simple/</guid>
      <description>常用命令 查看有哪些indexes curl -u [user]:[password] -XGET 127.0.0.1:9200/_cat/indices 删除索引 curl -u *:* -XDELETE 127.0.0.1:9200/story 查看type curl -u *:* -XGET 127.0.0.1:9200/story/_search?pretty 查看结构 curl -u *:* -XGET 127.0.0.1:9200/luka/_mapping?pretty 创建index curl -u *:* -H &#39;Content-Type:application/json&#39; -XPUT 127.0.0.1:9200/luka?pretty 模糊查询 curl -u *:* -XGET &#39;127.0.0.1:9200/story/_search?q=mary&amp;amp;pretty&#39; 查询 https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.html Match查询 curl -XGET &#39;localhost:9200/my_index/my_type/_search&#39; -d &#39;{ &amp;quot;query&amp;quot; : { &amp;quot;match&amp;quot; : { &amp;quot;testField&amp;quot; : &amp;quot;abc&amp;quot; } } }&#39; $data = [ &#39;body&#39; =&amp;gt; [ &#39;query&#39; =&amp;gt; [ &#39;match&#39; =&amp;gt; [ &#39;title&#39; =&amp;gt; &#39;黑猫&#39;, ] ], ] ]; Bool查询 curl -XGET &#39;localhost:9200/my_index/my_type/_search&#39; -d &#39;{ &amp;quot;query&amp;quot; : { &amp;quot;bool&amp;quot; : { &amp;quot;must&amp;quot;: [ { &amp;quot;match&amp;quot; : { &amp;quot;testField&amp;quot; : &amp;quot;abc&amp;quot; } }, { &amp;quot;match&amp;quot; : { &amp;quot;testField2&amp;quot; : &amp;quot;xyz&amp;quot; } } ] } } }&#39; $data = [ &#39;body&#39; =&amp;gt; [ &#39;query&#39; =&amp;gt; [ &#39;bool&#39; =&amp;gt;</description>
    </item>
    
    <item>
      <title>Graphql最大复杂度和最大深度设置</title>
      <link>/posts111/2018-09-19-graphql-maxth-depth/</link>
      <pubDate>Wed, 19 Sep 2018 16:44:46 +0800</pubDate>
      
      <guid>/posts111/2018-09-19-graphql-maxth-depth/</guid>
      <description>设置最大深度和最大负责度的好处 因为把查询的权利交给了客户端, 客户端可以进行非常复杂的查询. 因为客户端可能进行恶意的查询或者进行非常大的查询, 因此服务端要拒绝这样的查询. 总共有三种方式可以进行: 设置响应过期时间 设置查询最大深度 设置查询最大复杂度 设置响应过期时间需要对服务端代码和性能要求比较高, 可以先不管, 当服务器代码和性能上去再设置. 如何判断最大深度</description>
    </item>
    
    <item>
      <title>Compose Transporter -- 基于阿里云MongoDB和ES之间的数据同步</title>
      <link>/posts111/2018-06-13-compose-transporter/</link>
      <pubDate>Wed, 13 Jun 2018 21:59:26 +0800</pubDate>
      
      <guid>/posts111/2018-06-13-compose-transporter/</guid>
      <description>工具选型 主要查看这篇文章 mongo-connector elasticsearch-river-mongodb Logstash transporter Mongoosastic mongo-connector是mongodb-labs官方的开源项目. 但是官方不在支持, 关闭了issue, 导致很多问题无法找到答案, 也就无法解决遇到的问题 mongo-connector is not currently supported by MongoDB, Inc. If any community members would like to take over maintenance, please contact seth.payne@mongodb.com` elasticsearch-river-mongodb不支持elasticsearch5.0以版本. 最终选择Trans</description>
    </item>
    
    <item>
      <title>go 跨平台编译</title>
      <link>/posts111/2018-05-04-go-cross-complie/</link>
      <pubDate>Fri, 04 May 2018 05:30:16 +0000</pubDate>
      
      <guid>/posts111/2018-05-04-go-cross-complie/</guid>
      <description>Go编译支持的平台类型 amd64 (also known as x86-64) 386 (x86 or x86-32) arm (ARM) arm64 (AArch64) version &amp;gt;= 1.5 ppc64, ppc64le version &amp;gt;= 1.5 mips, mipsle (32-bit MIPS big- and little-endian) version &amp;gt;= 1.8 mips64, mips64le (64-bit MIPS big- and little-endian) version &amp;gt;= 1.6 s390x (IBM System z) version &amp;gt;= 1.7 $GOOS $GOARCH android arm darwin 386 darwin amd64 darwin arm darwin arm64 dragonfly amd64 freebsd 386 freebsd amd64 freebsd arm linux 386 linux amd64 linux arm linux arm64 linux ppc64 linux ppc64le linux mips linux mipsle linux mips64 linux mips64le linux s390x netbsd 386 netbsd amd64 netbsd arm openbsd 386 openbsd amd64 openbsd arm plan9 386 plan9 amd64 solaris amd64 windows 386 windows amd64 源码安装go 需要安装软件 apt-get install gcc git bzip2 note 想要go支持cgo, c编译器(比如: gcc, clang)必须先安装. 如果不</description>
    </item>
    
    <item>
      <title>Golang interface入门</title>
      <link>/posts111/2018-04-15-golang-interface-simple/</link>
      <pubDate>Sun, 15 Apr 2018 01:50:43 +0000</pubDate>
      
      <guid>/posts111/2018-04-15-golang-interface-simple/</guid>
      <description>定义 Interface是定义一组方法的集合 如何实现接口 任何type只要实现了interface的所有方法, 即可实现接口. 不需要像java需要使用implements关键字来显式声明. 所有的类型都实现了empty interfa1ce type I interface { M() } type T struct { S string } // T就实现了interface I, 不需要显式声明 func (t T) M() { fmt.Println(t.S) } func main() { var i I = T{&amp;quot;hello&amp;quot;} i.M() } Interface本质 inter</description>
    </item>
    
    <item>
      <title>Golang指针vs值</title>
      <link>/posts111/2018-03-24-golang-pointer-vs-value-vs-reference/</link>
      <pubDate>Sat, 24 Mar 2018 15:58:13 +0000</pubDate>
      
      <guid>/posts111/2018-03-24-golang-pointer-vs-value-vs-reference/</guid>
      <description>Go语言允许通过值和指针的方式来传递参数. 严格的说Go只允许通过值的方式来传递参数. 当一个变量被当做函数的参数传递, 那么这个变量一定会被复制, 然后传入被调用的函数里. 当这个变量被复制, 那么一定会重新开辟内存地址. 对于参数为值的时候: func test(p int) { fmt.Printf(&amp;quot;%p\n&amp;quot;, &amp;amp;p) // 0xc42000e250 } func main() { p := 10 fmt.Printf(&amp;quot;%p&amp;quot;, &amp;amp;p) // 0xc42000e218 test(p) } 从结果可以很容易看出来, 变量p和参数p是两个完全不一样地址, 就可以很容易理解</description>
    </item>
    
    <item>
      <title>Golang命名规范</title>
      <link>/posts111/2018-01-23-golang_named/</link>
      <pubDate>Tue, 23 Jan 2018 15:34:24 +0000</pubDate>
      
      <guid>/posts111/2018-01-23-golang_named/</guid>
      <description>文件名 没有明确的规定 根据test文件的命名规范推测, 还是使用下划线比较统一. 测试文件: path_test.go 版本区分: trap_windows_1.4.go 平台区分: file_windows.go CPU区分: vdso_linux_amd64.go 由于没有明确的文档说这个事情. 从源码来看, 我觉得&amp;lt;a href=&amp;quot;https://studygolang.com/articles/8542&amp;quot;&amp;gt;这篇文档归档的挺不错. 以后发现有别的规定再补充. 包</description>
    </item>
    
    <item>
      <title>使用阿里云OSS &#43; CDN遇到的问题及解决方式</title>
      <link>/posts111/2017-11-15-aliyun-oss-cdn/</link>
      <pubDate>Wed, 15 Nov 2017 12:05:39 +0000</pubDate>
      
      <guid>/posts111/2017-11-15-aliyun-oss-cdn/</guid>
      <description>一. OSS 配置 CDN加速 CDN(Content Delivery Network)是将源站内容分发至最接近用户的节点，使用户可就近取得所需内容，提高用户访问的响应速度和成功率. CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上 优点: 解决网络拥挤. 提高用户下载速度; 保护源服务器. 无论渗透攻击,还是DDos攻击</description>
    </item>
    
    <item>
      <title>爬虫小试-抓取JD图片</title>
      <link>/posts111/2017-10-03-spider-jd/</link>
      <pubDate>Tue, 03 Oct 2017 13:44:30 +0000</pubDate>
      
      <guid>/posts111/2017-10-03-spider-jd/</guid>
      <description>因为项目需要, 要抓取京东一些图片, 来进行分析使用.如https://item.jd.com/bigimage.aspx?id=11921955 我们想抓取的就是这个图片右侧的8张图片. 进过分析这个系列html源码, 发现8张图片的地址在js数组中. curl https://item.jd.com/bigimage.aspx?id=11921955 如果利用常规的requests + BeautifulSoup的话, 感觉只获取这个js数组就是一个挺麻烦的</description>
    </item>
    
    <item>
      <title>C&#43;&#43;实现ping</title>
      <link>/posts111/2017-08-25-cping/</link>
      <pubDate>Fri, 25 Aug 2017 12:02:07 +0000</pubDate>
      
      <guid>/posts111/2017-08-25-cping/</guid>
      <description>最近手头有点工作跟这个有段, 就实现一个简单ping. 就实现如图功能就行. 先说下原理: 使用ICMP协议, 组织ICMP包 socket_id = socket(AF_INET, SOCK_RAW, IPPROTO_ICMP); 告诉host我们要使用发送的报文是ICMP, 至于怎么发, 以及TCP通信的就是不是我们这里要关心的了 ##组织ICMP标示 p_icmp = (struct icmp *)buffer; p_icmp-&amp;gt;icmp_type = ICMP_ECHO; p_icmp-&amp;gt;icmp_code = 0; p_icmp-&amp;gt;icmp_cksum = 0; p_icmp-&amp;gt;icmp_seq = 12345; p_icmp-&amp;gt;icmp_id = getpid(); p_icmp-&amp;gt;icmp_cksum = checkSum((uint16_t*)p_icmp, 64); 这里组织我们需要的ICMP的一些标示 3.发送ICMP给ho</description>
    </item>
    
    <item>
      <title>LD_LIBRARY_PATH与-L的关系以及延伸</title>
      <link>/posts111/2017-08-25-ld_library_path/</link>
      <pubDate>Fri, 25 Aug 2017 11:56:24 +0000</pubDate>
      
      <guid>/posts111/2017-08-25-ld_library_path/</guid>
      <description>最近跟同学讨论c++在编译时g++ -L.. 和LD_LIBRARY_PATH的问题，今天在做一个东西的时候发现，我对这两个东西的理解是错误的，经过一番研究，写下我对这些东西的想法，如果有不对的地方，欢迎指正。 我遇到的问题： g++ multiple.cpp -L/usr/local/lib -lboost_program_options编译完后，ldd ./a.out发现libboost_program_options.</description>
    </item>
    
    <item>
      <title>有关LD_LIBRARY_PATH与ld.so.conf</title>
      <link>/posts111/2017-08-25-id_library_path_ld_so_conf/</link>
      <pubDate>Fri, 25 Aug 2017 11:55:53 +0000</pubDate>
      
      <guid>/posts111/2017-08-25-id_library_path_ld_so_conf/</guid>
      <description>我之前写过一篇关于LD_LIBRARY_PATH与gcc/g++ -L的关系的文章. 在用CPACK制作了一个Debian安装包，然后我在/home/.bashrc里添加了export LD_LIBRARY_PATH=/usr/loca/lib:$LD_LIBRARY_PATH, 这个不够优美, 经过一番寻找终于找到了&amp;mdash;ld.so.conf可以完美解决这个问题。 为什么LD_LIBRARY_PATH不行？ 可以看看老外是怎么说的 升级共享库时</description>
    </item>
    
    <item>
      <title>使用System V信号量同步引起的Interrupted system call坑</title>
      <link>/index.php/2017/08/25/ipc_interrupted_system_call/</link>
      <pubDate>Fri, 25 Aug 2017 11:54:11 +0000</pubDate>
      
      <guid>/index.php/2017/08/25/ipc_interrupted_system_call/</guid>
      <description>使用System V信号量不是那么熟练. 写了一个Monitor监测线程, 一个实际执行的Product线程. 本来的想法两个线程一个一个的调, 但是我忘了把另外一个线程注释掉了.然后坑就这么产生了. 先看Monitor代码: 然后gdb去调试的时候, 总是出现 我一开始以为我的程序出错了, 因为我System V信号量用的不是很熟练, 但是我发现我写的没有错呀, 都是这样</description>
    </item>
    
    <item>
      <title>修改系统时间导致的坑</title>
      <link>/index.php/2017/08/25/system_time/</link>
      <pubDate>Fri, 25 Aug 2017 11:53:30 +0000</pubDate>
      
      <guid>/index.php/2017/08/25/system_time/</guid>
      <description>有一天测试人员对我说, 我怎么测试10点开站会这个功能呢? 当时也没有经过脑子, 直接对她说, 你把系统时间修改一下吧. 好嘛, 麻烦来了. 测试对我说, 你新开发的程序有BUG, 程序没反应了. 我晕, 哥已经测过的, 怎么会有问题呢? 然后我就做在那开发排地雷. 后来经过仔细排查, 排查到一个别人封装的接口, 我把那个程序大致的样子写出来. 程序总是在这个函数中阻塞住. 为什么会</description>
    </item>
    
    <item>
      <title>记一次线程不同步的坑</title>
      <link>/index.php/2017/08/25/thread_error/</link>
      <pubDate>Fri, 25 Aug 2017 11:52:58 +0000</pubDate>
      
      <guid>/index.php/2017/08/25/thread_error/</guid>
      <description>这段简单的代码, 总是在某些时候, 就会出现p_cur_ctx-&amp;gt;GetCallbackContent()不为空, 但是总是memcpy失败的问题. 这下无语了, 系统库有问题了吗 ?! WTF, 遇见鬼了, 从来没有见过如此诡异的问题. GetCallbackContent()&#34; 怎么看, 这都是不可能发生的事情!!!, 为什么memcpy会失败呢? 再看GetCallbackContent()的代码实现 感觉上没有</description>
    </item>
    
    <item>
      <title>Golang Label使用方法</title>
      <link>/posts111/2017-08-10-label/</link>
      <pubDate>Thu, 10 Aug 2017 06:07:19 +0000</pubDate>
      
      <guid>/posts111/2017-08-10-label/</guid>
      <description>写C/C++的时候, 基本上都是建议不要使用goto的, 因为goto运用的不好的话, 会改变程序的运行结构, 会造成程序运行的混乱. 所以很少能看到C++代码中有使用goto的. 不过看到Golang中, 不仅保留了goto, 而且把它发扬光大了. 在Golang中能使用Label的有goto, break, continue. 这篇文章就介绍下Golang中Label使用和注意点. 注意点: La</description>
    </item>
    
    <item>
      <title>golang面向对象分析</title>
      <link>/posts111/2017-07-24-golang_oop/</link>
      <pubDate>Mon, 24 Jul 2017 01:51:37 +0000</pubDate>
      
      <guid>/posts111/2017-07-24-golang_oop/</guid>
      <description>说道面向对象(OOP)编程, 就不得不提到下面几个概念: 抽象 封装 继承 多态 其实有个问题Is Go An Object Oriented Language?, 随便谷歌了一下, 你就发现讨论这个的文章有很多: reddit google group 那么问题来了 Golang是OOP吗? 使用Golang如何实现OOP? 我入门教程基本就是A Tour Of Go以及Go Web 编程. 由于之前是写C++, 但是说到Go面向对象编程, 总是感觉怪怪的, 总感觉缺少点什么. 我搜集了一</description>
    </item>
    
    <item>
      <title>golang中defer, panic, recover用法</title>
      <link>/posts111/2017-07-20-golang_defer_panic_recover/</link>
      <pubDate>Thu, 20 Jul 2017 09:49:28 +0000</pubDate>
      
      <guid>/posts111/2017-07-20-golang_defer_panic_recover/</guid>
      <description>昨天谢大在群里发了一个golang面试题, 第一题就不会做了. 这题主要是考察defer, panic, 于是各种谷歌, 就写下了这篇文章, 由于本人水平有限, 有哪些理解不到的地方, 请在下面留言指出 一. defer 用法 为何会有defer这样的语法呢? 如果你之前是写C++的话这样的代码, 你会经常看到. class Demo { public: Demo() { p = new int(10); } ~Demo() { if (p) { delete(p); } } private: int *p = nullptr; } 本来就是想要简单使用某个变量(比</description>
    </item>
    
    <item>
      <title>nginx代理wordpress无法访问的问题</title>
      <link>/posts111/2017-07-19-wordpress_error/</link>
      <pubDate>Wed, 19 Jul 2017 09:22:00 +0000</pubDate>
      
      <guid>/posts111/2017-07-19-wordpress_error/</guid>
      <description>先说说我遇到的问题, 这简直就是坑中之王. 最近心血来潮, 购买了一台ECS服务器. 就在服务器上搭建了一个WordPress服务. 由于当时域名还没有通过备案. 只好使用IP的方式进行WordPress安装, 安装完成后, 也能使用IP的方式访问网站. 突然今天通知域名通过备案了, 当时那个激动的, 立马给自己的网站换成域名的方式. 然后傻眼了. 无论我怎么在浏览器中输入</description>
    </item>
    
    <item>
      <title>mongodb联表查询</title>
      <link>/posts111/2017-06-17-mongodb_joint_query/</link>
      <pubDate>Sat, 17 Jun 2017 14:36:31 +0000</pubDate>
      
      <guid>/posts111/2017-06-17-mongodb_joint_query/</guid>
      <description>picture_books表 bookshelfs表 现在下面的需求: bookshelf表的绘本列表展示(分页) picture_book的status为1的需要为一组, 且按照时间排序 picture_book的status不为1需要分为一组, 且按照时间排序 Note: 数据库: mongodb 关系: bookshelf通过bookshelfabld_id和picture_book的</description>
    </item>
    
  </channel>
</rss>
